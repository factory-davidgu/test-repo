<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Landing Page - WebGL Shader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        .content {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            color: white;
            text-align: center;
            padding: 20px;
            pointer-events: none;
        }
        
        h1 {
            font-size: 4rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-shadow: 0 2px 20px rgba(0, 0, 0, 0.8);
            letter-spacing: -0.02em;
        }
        
        p {
            font-size: 1.5rem;
            font-weight: 300;
            max-width: 600px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
            line-height: 1.6;
        }
        
        .cta {
            margin-top: 2rem;
            pointer-events: all;
        }
        
        button {
            padding: 1rem 2.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            border: 2px solid rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: white;
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.2);
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            p {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="content">
        <h1>Welcome to the Future</h1>
        <p>Experience the power of generative art and procedural graphics</p>
        <div class="cta">
            <button onclick="alert('Let\'s build something amazing!')">Get Started</button>
        </div>
    </div>

    <script src="https://unpkg.com/launchdarkly-js-client-sdk@3"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }
        
        // Resize canvas to match display size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // LaunchDarkly initialization
        // Note: In production, use a real client-side ID from LaunchDarkly
        const LAUNCHDARKLY_CLIENT_ID = 'demo-client-id';
        let ldClient = null;
        let animationSpeedMultiplier = 1.0;
        let useVibrantColors = true;
        
        // Initialize LaunchDarkly client
        async function initLaunchDarkly() {
            try {
                // Create an anonymous user context
                const context = {
                    kind: 'user',
                    key: 'anonymous-user-' + Math.random().toString(36).substring(7),
                    anonymous: true
                };
                
                // Initialize the client (will use defaults if client ID is invalid)
                ldClient = LDClient.initialize(LAUNCHDARKLY_CLIENT_ID, context);
                
                // Wait for client to be ready
                await ldClient.waitForInitialization();
                
                // Get feature flags
                animationSpeedMultiplier = ldClient.variation('animation-speed', 1.0);
                useVibrantColors = ldClient.variation('vibrant-colors', true);
                
                console.log('LaunchDarkly initialized successfully');
                console.log('Animation speed multiplier:', animationSpeedMultiplier);
                console.log('Use vibrant colors:', useVibrantColors);
                
                // Listen for flag changes
                ldClient.on('change', (changes) => {
                    if (changes['animation-speed']) {
                        animationSpeedMultiplier = changes['animation-speed'].current;
                        console.log('Animation speed updated to:', animationSpeedMultiplier);
                    }
                    if (changes['vibrant-colors']) {
                        useVibrantColors = changes['vibrant-colors'].current;
                        console.log('Vibrant colors updated to:', useVibrantColors);
                    }
                });
            } catch (error) {
                console.warn('LaunchDarkly initialization failed, using defaults:', error.message);
                // Continue with default values
            }
        }
        
        // Start LaunchDarkly initialization (non-blocking)
        initLaunchDarkly();
        
        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;
        
        // Fragment shader - inspired by compact raymarching shader
        const fragmentShaderSource = `
            precision mediump float;
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_colorVibrancy;
            
            mat2 rotate2D(float a) {
                float s = sin(a);
                float c = cos(a);
                return mat2(c, -s, s, c);
            }
            
            void main() {
                vec2 FC = gl_FragCoord.xy;
                vec2 r = u_resolution;
                float t = u_time;
                vec4 o = vec4(0.0);
                
                // Raymarching loop inspired by the provided shader
                for(float i = 1.0; i < 100.0; i += 1.0) {
                    float d = i * 0.08;
                    float s;
                    
                    // Create 3D point with rotation
                    vec2 uv = (FC.xy * 2.0 - r.xy) / r.y;
                    vec3 p = vec3(uv * d * rotate2D(t * 0.5), d - 8.0);
                    p.xz *= rotate2D(t * 0.5);
                    
                    // Distance field calculation
                    vec3 q = fract(p) * p;
                    s = 0.012 + 0.07 * abs(max(sin(length(q)), length(p) - 4.0) - i / 100.0);
                    
                    // Accumulate color with phase-shifted sine waves
                    // Use u_colorVibrancy to control color intensity
                    vec4 c = u_colorVibrancy * sin(vec4(1.0, 2.0, 3.0, 1.0) + i * 0.3) / s;
                    c = max(c, -length(p * p) * 0.0002);
                    o += c;
                }
                
                // Color grading (approximating tanh)
                o = o * o / 80000.0;
                o = o / (1.0 + o);
                
                // Enhance vibrancy
                o = pow(o * 4.0, vec4(0.65));
                
                gl_FragColor = vec4(clamp(o.rgb, 0.0, 1.0), 1.0);
            }
        `;
        
        // Create and compile shaders
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // Create program
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            
            return program;
        }
        
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);
        
        // Set up geometry (full-screen quad)
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
            -1, -1,
             1, -1,
            -1,  1,
            -1,  1,
             1, -1,
             1,  1,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        
        // Get attribute and uniform locations
        const positionLocation = gl.getAttribLocation(program, 'position');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const colorVibrancyLocation = gl.getUniformLocation(program, 'u_colorVibrancy');
        
        // Animation loop
        function render(time) {
            time *= 0.001; // Convert to seconds
            
            // Apply animation speed multiplier from LaunchDarkly
            const adjustedTime = time * animationSpeedMultiplier;
            
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(program);
            
            // Set up position attribute
            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Set uniforms - use adjusted time for animation speed control
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, adjustedTime);
            gl.uniform1f(colorVibrancyLocation, useVibrantColors ? 1.3 : 0.8);
            
            // Draw
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            requestAnimationFrame(render);
        }
        
        requestAnimationFrame(render);
    </script>
</body>
</html>
